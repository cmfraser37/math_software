###############################################
# written by Chris Fraser, version 6/4/2017, code which supports 
#
#
#  Code to compute the cluster modular group for Gr(3,9) and Gr(4,8). One should make a choice of either (k,n)=(3,9) or (k,n) = (4,8), although many of the functions
#  here could be adjusted slightly to work for Gr(k,n) where n is <= 8.   
# 
# Running CheckEverything(k,n) should verify everything claimed in our paper. 
#
# The key things that need to be checked are that: 
#   1) every cluster variable is a web. To do this: run FD(k,n), producing an instance of a fundamental domain object for Gr(k,n), and then 
#      run FD.Clusters(), which computes every cluster variable and cluster on the domain. An assertion will break if the cluster variable is not a web.
#   2) the orientation-preserving cluster modular group is generated by the Artin generators and the twist. To check this, run CycleBasisFromSpanningTree(k,n) and CheckTwoCycles(k,n). An assertion will 
#       break if a given cycle is not in the group.  
#####################################



import itertools
    
def CheckEverything(k,n):
    a = QQ.one()
    print "computing the Fundamental Domain, this takes a while"
    FD = Fundamental_Domain(k,n)    
    G = FD._QLoopGraph
    H = FD._QGraph
    QP = FD._QuiversPaths
    QL = FD._QuiversList
    mQL = FD._mQuiversList
    print "checking each cluster variable is a web"
    clusters = FD.Clusters()
    print "each cluster variable is a web"
    if (k,n) == (4,8):
        M= MatrixWithTrivialFrozens4(4*a,9*a/2,37*a,27*a/20,3*a/2,8*a,2*a,2*a,1*a)
        cmgimages = CMGImagesOfInitialCluster(M,clusters[0],9)
        save(G,'FullGraph48')
        save(H,'SpanningTree48')
        save(QP,'QuiversPaths48')
        save(QL,'QuiversList48')
        save(clusters,'Clusters48')
        save(cmgimages,'CMGImages48')
    elif (k,n) == (3,9):
        M= MatrixWithTrivialFrozens3(-2*a,-4*a,-6*a,-9*a,-12*a,8*a,4*a,3*a,2*a,1*a)
        cmgimages = CMGImagesOfInitialCluster(M,clusters[0],11)
        save(G,'FullGraph39')
        save(H,'SpanningTree39')
        save(QP,'QuiversPaths39')
        save(QL,'QuiversList39')
        save(clusters,'Clusters39')
        save(cmgimages,'CMGImages39')
    print "checking each cycle in the quiver mutation graph is in our group"
    A,B = CycleBasisFromSpanningTree(k,n)
    print "each cycle in the quiver mutation graph is in our group"
    print "checking each 2-cycle in the quiver mutation graph is in our group"
    CheckTwoCycles(k,n)
    print "each 2-cycle in the quiver mutation graph is in our group"

#  check that each elt of the cycle basis is in the CMG; thus the expected elts generate the CMG.   
def CycleBasisFromSpanningTree(k,n):
    cluster_size = (k-1)*(n-k-1)
    a = QQ.one()
    if (k,n) == (3,9):
        M= MatrixWithTrivialFrozens3(-2*a,-4*a,-6*a,-9*a,-12*a,8*a,4*a,3*a,2*a,1*a)
        G = Graph(load('FullGraph39.sobj'))
        H = load('SpanningTree39.sobj')
        QP = load('QuiversPaths39.sobj')
        QL = load('QuiversList39.sobj')
        cmgimages = load('CMGImages39.sobj')
        clusters = load('Clusters39.sobj')
    elif (k,n) == (4,8): 
        M= MatrixWithTrivialFrozens4(4*a,9*a/2,37*a,27*a/20,3*a/2,8*a,2*a,2*a,1*a)
        G = Graph(load('FullGraph48.sobj'))
        H = load('SpanningTree48.sobj')
        QP = load('QuiversPaths48.sobj')
        QL = load('QuiversList48.sobj')
        cmgimages = load('CMGImages48.sobj')
        clusters = load('Clusters48.sobj')
    print "loaded all saved data,made the matrix"
    Nclusters = MakeNClusters(clusters,M)
    print "made the numerical clusters. looping through cycles in the quiver exchange graph"
    ctr = 0
    badedges = []
    imagesreached = set()
    mQL0 = MutableSubquiver(QL[0],cluster_size)
    for edge in G.edges():
        if edge not in H.edges():
            if ctr %100 == 0:
                print "round= ",ctr, "# of bad cycles found = ",len(badedges),"number of CMG elts found= ",len(imagesreached)
            head,tail = edge[0], edge[1]
            #print "testing", QP[head],QP[tail], head,tail
            if len(QP[head]) >= len(QP[tail]):
                T = NumericalTestALoop(Nclusters[head],QL[head],MutableSubquiver(QL[tail],cluster_size),QP[tail],mQL0,k,n)
            else: 
                T = NumericalTestALoop(Nclusters[tail],QL[tail],MutableSubquiver(QL[head],cluster_size),QP[head],mQL0,k,n)
            if cmgimages.count(T):
                imagesreached.update([cmgimages.index(T)])
            else:
                print "bad",ctr
                print T
                return False
                badedges.append(edge)
            ctr +=1
    return badedges, imagesreached


    
#  check that each elt of the cycle basis is in the CMG; thus the expected elts generate the CMG.   
def CheckTwoCycles(k,n):
    cluster_size = (k-1)*(n-k-1)
    a = QQ.one()
    if (k,n) == (3,9):
        M= MatrixWithTrivialFrozens3(-2*a,-4*a,-6*a,-9*a,-12*a,8*a,4*a,3*a,2*a,1*a)
        G = Graph(load('FullGraph39.sobj'))
        H = load('SpanningTree39.sobj')
        QP = load('QuiversPaths39.sobj')
        QL = load('QuiversList39.sobj')
        cmgimages = load('CMGImages39.sobj')
        clusters = load('Clusters39.sobj')
    elif (k,n) == (4,8): 
        M= MatrixWithTrivialFrozens4(4*a,9*a/2,37*a,27*a/20,3*a/2,8*a,2*a,2*a,1*a)
        G = Graph(load('FullGraph48.sobj'))
        H = load('SpanningTree48.sobj')
        QP = load('QuiversPaths48.sobj')
        QL = load('QuiversList48.sobj')
        cmgimages = load('CMGImages48.sobj')
        clusters = load('Clusters48.sobj')
    print "loaded all saved data,made the matrix"
    Nclusters = MakeNClusters(clusters,M)
    print "made the numerical clusters. checking each 2-cycle in the quiver exchange graph"
    for head in G.vertices():
        for tail in G.neighbors(head): 
            mQLh,mQLt = MutableSubquiver(QL[head],cluster_size),MutableSubquiver(QL[tail],cluster_size)
            Towards = DirectionsForNeighbors(mQLh,mQLt)
            for towards in Towards:
                Q = copy(mQLh)
                Q.mutate(towards)
                Away = DirectionsForNeighbors(Q,mQLh)
                for away in Away:
                    if (towards >= away):     #get rid of inverses and obviously trivial 2-cycles
                        continue
                    else:
                        print "round = ",head,"2-cycle = ",(towards,away)
                        Q = copy(mQLh)
                        CurrentNCVs = copy(Nclusters[head][:cluster_size])
                        for direction in [towards,away]:
                            plusstr = Nclusters[head][0].parent().one()
                            minusstr = Nclusters[head][0].parent().one()
                            columnvec = Q.b_matrix().transpose()[direction]
                            Q.mutate(direction)
                            for x in range(cluster_size):
                                if columnvec[x] == 1:
                                    plusstr *= CurrentNCVs[x]
                                elif columnvec[x] == -1:
                                    minusstr *= CurrentNCVs[x]
                                elif columnvec[x] == 2:
                                    plusstr *= CurrentNCVs[x]
                                    plusstr *=CurrentNCVs[x]
                                elif columnvec[x] == -2:
                                    minusstr *= CurrentNCVs[x]
                                    minusstr*= CurrentNCVs[x]
                            NewCV = (plusstr+minusstr)/CurrentNCVs[direction]
                            CurrentNCVs[direction] = NewCV
                        T = set(CurrentNCVs)
                        assert Q._digraph.is_isomorphic(mQLh._digraph)
                        assert SearchForCMGImages(M,clusters[head][:cluster_size],T,8)
    
# test a given cycle is in CMG numerically by applying CMG elements TO the matrix M
def NumericalTestALoop(Ncluster,InitialQuiver,NextmQuiver,mQP,QL0,k,n):
    cluster_size = (k-1)*(n-k-1)
    Q = ClusterQuiver(copy(InitialQuiver))
    mQ = ClusterQuiver(MutableSubquiver(Q,cluster_size))
    NextmQ = ClusterQuiver(NextmQuiver)
    CurrentNCVs = copy(Ncluster)
    tempmQP = copy(mQP)
    for i in range(len(mQP)+1):        
        direction = DirectionsForNeighbors(mQ,NextmQ,fast = True)
        #print direction
        plusstr = CurrentNCVs[0].parent().one()
        minusstr = CurrentNCVs[0].parent().one()
        columnvec = Q.b_matrix().transpose()[direction]
        Q.mutate(direction)
        mQ.mutate(direction)
        if len(tempmQP):
            NextmQ.mutate(tempmQP[-1])
            tempmQP.pop()
        for x in range(cluster_size+n):
            if columnvec[x] == 1:
                plusstr *= CurrentNCVs[x]
            elif columnvec[x] == -1:
                minusstr *= CurrentNCVs[x]
            elif columnvec[x] == 2:
                plusstr *= CurrentNCVs[x]
                plusstr *=CurrentNCVs[x]
            elif columnvec[x] == -2:
                minusstr *= CurrentNCVs[x]
                minusstr*= CurrentNCVs[x]
        NewCV = (plusstr+minusstr)/CurrentNCVs[direction]
        CurrentNCVs[direction] = NewCV
    assert MutableSubquiver(Q,cluster_size)._digraph.is_isomorphic(QL0._digraph)
    T = set(CurrentNCVs)
    return T






            
            
#takes in 10 values. 
#A..F must be negative and G..K must be positive, and the assertions need to hold. 
# returns a totally positive matrix, all of whose frozen variables are 1. This avoids division by zero issues when computing clusters. 
def MatrixWithTrivialFrozens3(A,B,C,D,E,G,H,I,J,K):
    LL,MM,NN = [0 for i in range(9)],[0 for i in range(9)],[0 for i in range(9)]
    assert A < 0 and B < 0 and C < 0 and D < 0 and E < 0
    assert (A*H-B*G) >0 
    assert (B*I-C*H) >0 
    assert (C*J-D*I) >0 
    assert (D*K-E*J) >0 
    F = (E-1)/K
    L = (B-1)/A
    M = (1+L*(A*I-G*C)-B*I+H*C)/(A*H-B*G)
    N = (1+M*(B*J-D*H)-L*(C*J-D*I))/(B*I-C*H)
    O = (1+N*(C*K-E*I)-M*(D*K-E*J))/(C*J-D*I)
    P = (1+O*(D-F*J)-N*(E-F*K))/(D*K-E*J)
    LL[0],LL[3],LL[4],LL[5],LL[6],LL[7],LL[8] = 1,1,L,M,N,O,P
    MM[1],MM[3],MM[4],MM[5],MM[6],MM[7],MM[8] = 1,A,B,C,D,E,F
    NN[2],NN[3],NN[4],NN[5],NN[6],NN[7],NN[8] = 1,G,H,I,J,K,1
    M = matrix(QQ,3,9,LL+MM+NN)
    
    frozenslist = [[i,i+1,i+2] for i in range(6)]+[[0,7,8]]+[[0,1,8]]
    for frozen in frozenslist:
        assert M.matrix_from_columns(frozen).determinant() ==1
    for Plu in itertools.combinations(range(0,9),3):
        assert (M.matrix_from_columns([x for x in Plu]).determinant() >0)
    return M

#matrix looks like 1 0 0 0 | -1 -A -B -C         
#                  0 1 0 0 | D   E  F  G
#                  0 0 1 0 | -H -I -J  -K
#                  0 0 0 1 | L   M  N  1      
#input D,E,F,H,I,J,L,M,N all >0



def MatrixWithTrivialFrozens4(D,E,F,H,I,J,L,M,N):
    #positivity conditions
    assert I*L-H*M>0
    assert J*M-I*N>0
    assert D*(J*M-I*N)-E*(J*L-H*N)+F*(I*L-H*M)>0
    assert E*H-D*I>0
    #print 'IL-HM', I*L-H*M
    #print 'JM-IN', J*M-I*N
    #print 'EH-DI', E*H-D*I
    #print 'D(JM-IN)-E(JL-HN)+F(IL-HM)',D*(J*M-I*N)-E*(J*L-H*N)+F*(I*L-H*M)
    #assert H,D,L,M,N>0

    #trivial frozens conditions
    K = (1+J)/N
    G = (1-E+F*(K*M-I))/(J*M-I*N)
    A = (1+E)/D
    B= (1-J-F*(I-A*H))/(E*H-D*I)
    C=(1+(E-F*(K*M-I)+G*(J*M-I*N))-A*(D-F*(K*L-H)+G*(J*L-H*N))+B*(D*(K*M-I)-E*(K*L-H)+G*(I*L-H*M)))/(D*(J*M-I*N)-E*(J*L-H*N)+F*(I*L-H*M))
    LL,MM,NN,OO = [0 for i in range(8)],[0 for i in range(8)],[0 for i in range(8)],[0 for i in range(8)]
    LL[0],LL[4],LL[5],LL[6],LL[7] = 1,-1,-A,-B,-C
    MM[1],MM[4],MM[5],MM[6],MM[7] = 1,D,E,F,G
    NN[2],NN[4],NN[5],NN[6],NN[7] = 1,-H,-I,-J,-K
    OO[3],OO[4],OO[5],OO[6],OO[7] = 1,L,M,N,1
    M = matrix(QQ,4,8,LL+MM+NN+OO)    
    frozenslist = [[i,i+1,i+2,i+3] for i in range(5)]+[[0,1,2,7],[0,1,6,7],[0,5,6,7]]
    for frozen in frozenslist:
        assert M.matrix_from_columns(frozen).determinant() ==1
    for Plu in itertools.combinations(range(0,8),4):
        assert (M.matrix_from_columns([x for x in Plu]).determinant() >0)
    return M

#one can take for example D,E,F,H,I,J,L,M,N = 1,2,5,2,2,2,3,2,1  although not all Plus are distinct on this matrix  
def CheckKer48Relation(D,E,F,H,I,J,L,M,N):
    M1 = MatrixWithTrivialFrozens4(D,E,F,H,I,J,L,M,N)
    M2 = Sigma1(Sigma2(Sigma3(Sigma3(Sigma2(Sigma1(M1))))))
    for Plu in itertools.combinations(range(0,8),4):
        assert (M1.matrix_from_columns([x for x in Plu]).determinant() == M2.matrix_from_columns([x for x in Plu]).determinant())
    return M1,M2        
    
    
    
    
    
    
    
# starting with a matrix M, act on M by rotations, twists, and the Garside element. Then evaluate the initial cluster variables on it to get numerical 
# cluster variables. Return this list of numerical clusters. 
def CMGImagesOfInitialCluster(M,cluster,degreeingens):
    k,n = M.nrows(),M.ncols()
    degreectr = 1
    NDistantClusterOnRoot = []
    if k ==3:
        N1,N2,N3,N4 = copy(M),NumericallyTwistMatrix(copy(M)),NumericallyFGRotateMatrix(copy(M)),NumericallyFGRotateMatrix(NumericallyTwistMatrix(copy(M)))
        CurrentMatrices = [N1,N2,N3,N4]
        while degreectr < degreeingens:
            #print degreectr,len(CurrentMatrices)
            temp = []
            for currentmatrix in CurrentMatrices:
                if degreectr < degreeingens-1:
                    temp.append(NumericallyFGRotateMatrix(NumericallyRotateMatrix(copy(currentmatrix))))
                    temp.append(NumericallyFGRotateMatrix(NumericallyRotateMatrix(NumericallyRotateMatrix(copy(currentmatrix)))))
                for i in range(n):
                    NDistantClusterOnRoot.append(set([NumericalClusterVariable(x,currentmatrix) for x in cluster]))
                    currentmatrix = NumericallyRotateMatrix(currentmatrix)
            CurrentMatrices = copy(temp)
            degreectr+=1        
        return NDistantClusterOnRoot
    if k ==4:
        N1,N2 = copy(M),NumericallyTwistMatrix(copy(M))
        N3,N4,N5 = Sigma3(M),Sigma3(Sigma2(M)),Sigma3(Sigma2(Sigma1(M)))
        N6,N7,N8 = Sigma3(N2),Sigma3(Sigma2(N2)),Sigma3(Sigma2(Sigma1(N2)))
        CurrentMatrices = [N1,N2,N3,N4,N5,N6,N7,N8]
        temp = []
        for x in range(8):
            temp.append(Sigma212(CurrentMatrices[x]))
        CurrentMatrices += temp
        while degreectr < degreeingens:
            #print degreectr,len(CurrentMatrices)
            temp = []
            for currentmatrix in CurrentMatrices:
                if degreectr < degreeingens-1:
                    temp.append(Sigma212(Sigma21(currentmatrix)))
                    temp.append(Sigma212(Sigma21(Sigma21(currentmatrix))))
                for j in range(8):
                    NDistantClusterOnRoot.append(set([NumericalClusterVariable(x,currentmatrix) for x in cluster]))
                    currentmatrix = NumericallyRotateMatrix(currentmatrix)
            CurrentMatrices = copy(temp)
            degreectr+=1        
        return NDistantClusterOnRoot      

def SearchForCMGImages(M,cluster,targetNcluster,degreeingens):
    k,n = M.nrows(),M.ncols()
    degreectr = 1
    if k ==3:
        N1,N2,N3,N4 = copy(M),NumericallyTwistMatrix(copy(M)),NumericallyFGRotateMatrix(copy(M)),NumericallyFGRotateMatrix(NumericallyTwistMatrix(copy(M)))
        CurrentMatrices = [N1,N2,N3,N4]
        while degreectr < degreeingens:
            #print degreectr,len(CurrentMatrices)
            temp = []
            for currentmatrix in CurrentMatrices:
                if degreectr < degreeingens-1:
                    temp.append(NumericallyFGRotateMatrix(NumericallyRotateMatrix(copy(currentmatrix))))
                    temp.append(NumericallyFGRotateMatrix(NumericallyRotateMatrix(NumericallyRotateMatrix(copy(currentmatrix)))))
                for j in range(n):
                    if set([NumericalClusterVariable(x,currentmatrix) for x in cluster]) == targetNcluster:
                        return True
                    currentmatrix = NumericallyRotateMatrix(currentmatrix)
            CurrentMatrices = copy(temp)
            degreectr+=1        
        return False
    if k ==4:
        N1,N2 = copy(M),NumericallyTwistMatrix(copy(M))
        N3,N4,N5 = Sigma3(M),Sigma3(Sigma2(M)),Sigma3(Sigma2(Sigma1(M)))
        N6,N7,N8 = Sigma3(N2),Sigma3(Sigma2(N2)),Sigma3(Sigma2(Sigma1(N2)))
        CurrentMatrices = [N1,N2,N3,N4,N5,N6,N7,N8]
        temp = []
        for x in range(8):
            temp.append(Sigma212(CurrentMatrices[x]))
        CurrentMatrices += temp
        while degreectr < degreeingens:
            #print degreectr,len(CurrentMatrices)
            temp = []
            for currentmatrix in CurrentMatrices:
                if degreectr < degreeingens-1:
                    temp.append(Sigma212(Sigma21(currentmatrix)))
                    temp.append(Sigma212(Sigma21(Sigma21(currentmatrix))))
                for j in range(8):
                    if set([NumericalClusterVariable(x,currentmatrix) for x in cluster]) == targetNcluster:
                        return True
                    currentmatrix = NumericallyRotateMatrix(currentmatrix)
            CurrentMatrices = copy(temp)
            degreectr+=1        
        return False    






# return the index ii of a quiver in TS that is isomorphic to Q
def Find_equivalent(Q,TS,start_val = 0):
    HD = Q.digraph()
    for ii in range(start_val,len(TS)):
        if HD.is_isomorphic(TS[ii]._digraph):
            return ii
    return -1
    
#return the directions k such that mu_k(Q) is isom. to Q1
# if fast is True: return the first index that works. 
def DirectionsForNeighbors(Q,Q1,fast = False):
    out = []
    for i in range(Q.n()):
        Q0 = ClusterQuiver(copy(Q))
        Q0.mutate(i)
        if Q0._digraph.is_isomorphic(Q1._digraph):
            out.append(i)
            if fast:
                return i
        #Q.mutate(i)
    return out


def MutableSubquiver(Q,cluster_size):
        return ClusterQuiver(Q.b_matrix()[0:cluster_size,0:cluster_size])
        



                
                
#input degree (as string), output possible web-strings in our nomenclature    
def DegreeToWebString(D,k,n):
    if D == '123344556778':
        return '345m457v678m123'
    DL = []
    for x in D:
        if int(x)%n == 0:
            DL.append(str(n))
        else:
            DL.append(str(int(x)%n))
    DL.sort()
    D = str().join(DL)
    if D == '123344556778':
       return ['567m34v345m78v12']
    elif D == '122334567788':
        return ['234m57v678m12v83']   
    elif D == '122345567788':
       return ['128m67v457m23v58']
    elif D == '112233445678':
       return ['123m78v345m12v46']       
    elif D == '123344556678':
       return ['345m12v567m34v68']       
    elif len(D) == k:
       return [str().join(D)]    
    elif len(D) == 2*k:
        if k==3:    
            Hexapod1 = [D[:k-1],D[k-1:2*k-2],D[2*k-2:2*k]]
            Hexapod2 = [[D[0]+D[2*k-1]],D[1:k],D[k:2*k-1]]
            HexapodString = str().join(Hexapod1[0])+'m'+ str().join(Hexapod1[1])+'m' + str().join(Hexapod1[2])
            HexapodString2 = str().join(Hexapod2[0])+'m'+ str().join(Hexapod2[1])+'m' + str().join(Hexapod2[2])
            return [HexapodString,HexapodString2]
        if k==4:
            if D == str().join([str(i) for i in range(1,n+1)]):
                return ['123m456v78','234m567v18','345m678v12','178m456v23','567m128v34','123m678v45','178m234v56','345m128v67']
            else:
                dup = [s for s in D if D.count(s) ==2][0]
                dupind = D.index(dup)
                threeD = D+D+D
                out =[threeD[2*k+dupind+1:2*k+dupind+4]+'m'+threeD[2*k+dupind-2:2*k+dupind+1]+'v'+threeD[2*k+dupind-3]+threeD[2*k+dupind-4],threeD[2*k+dupind+1:2*k+dupind+4]+'m'+threeD[2*k+dupind-2:2*k+dupind+1]+'v'+threeD[2*k+dupind-4]+threeD[2*k+dupind-3]]
                out += [threeD[2*k+dupind-1]+threeD[2*k+dupind+1:2*k+dupind+3]+'m'+threeD[2*k+dupind-3:2*k+dupind-1]+dup+'v'+threeD[2*k+dupind+3]+threeD[2*k+dupind+4],threeD[2*k+dupind-1]+threeD[2*k+dupind+1:2*k+dupind+3]+'m'+threeD[2*k+dupind-3:2*k+dupind-1]+dup+'v'+threeD[2*k+dupind+4]+threeD[2*k+dupind+3]]
                out +=[threeD[2*k+dupind-1]+threeD[2*k+dupind+1:2*k+dupind+3]+'m'+dup+threeD[2*k+dupind+3:2*k+dupind+5]+'v'+threeD[2*k+dupind-3]+threeD[2*k+dupind-2],threeD[2*k+dupind-1]+threeD[2*k+dupind+1:2*k+dupind+3]+'m'+dup+threeD[2*k+dupind+3:2*k+dupind+5]+'v'+threeD[2*k+dupind-2]+threeD[2*k+dupind-3]]
                return out
    if len(D) == 3*k:
        if k==3:
            if D == '123456789':
                return ['12m34v5v67m89','19m78v6v23m45','12m89v7v34m56','19m23v8v45m67','12m34v9v56m78','23m45v1v67m89','19m78v2v34m56','12m89v3v45m67','19m23v4v56m78']    
            Dstr = []
            while D[0] != D[1]:
                D = D[1:] + D[0]
            bundles = [[[1,2],[3,4],[0,8],[6,7],5],[[1,3],[4,5],[0,2],[7,8],6],[[1,8],[2,3],[0,7],[5,6],4]]
            for x in bundles:
                temp0 = [D[y] for y in x[0]]
                temp1 = [D[y] for y in x[1]]
                temp2 = [D[y] for y in x[2]]
                temp3 = [D[y] for y in x[3]]
                temp4 = 'v' + str(D[x[4]]) + 'v'
                temp0.sort()
                temp1.sort()
                temp2.sort()
                temp3.sort()
                if int(temp0[0]) < int(temp1[0]):
                    str0 = str().join(temp0) + 'm' + str().join(temp1)
                else :
                    str0 = str().join(temp1) + 'm' + str().join(temp0)

                if int(temp2[0]) < int(temp3[0]):
                    str1 = str().join(temp2) + 'm' + str().join(temp3)
                else :
                    str1 = str().join(temp3) + 'm' + str().join(temp2)
                if int(str0[0]) < int(str1[0]):
                    Dstr.append(str0+temp4+ str1)                
                else:
                    Dstr.append(str1+temp4+ str0)                
            return Dstr
        #return []

        elif k==4: #345m12v781m56v (not 1 or 2 or 5 or 6)
            dups = [s for s in D if D.count(s) ==2]
            dup1,dup2,dup3,dup4 = dups[0],dups[2],dups[4],dups[6]
            dup1ind,dup2ind,dup3ind,dup4ind = D.index(dup1),D.index(dup2),D.index(dup3),D.index(dup4) 
            out = []
            if int(dup3) == int(dup1)+4:
                Dsnip = D[:dup2ind+1]+D[dup2ind+2:dup4ind+1]+D[dup4ind+2:]
                threeD = Dsnip+Dsnip+Dsnip
                rtA,rtB,lftA,lftB = threeD[10+dup1ind+1:10+dup1ind+4],threeD[10+dup1ind+6:10+dup1ind+9],threeD[10+dup1ind-2:10+dup1ind+1],threeD[10+dup1ind-7:10+dup1ind-4]
                out += [rtA+'m'+threeD[10+dup1ind+4:10+dup1ind+6]+'v'+rtB+'m'+threeD[10+dup1ind-1:10+dup1ind+1]+'v'+dup2+dup4,rtA+'m'+threeD[10+dup1ind+4:10+dup1ind+6]+'v'+rtB+'m'+threeD[10+dup1ind-1:10+dup1ind+1]+'v'+dup4+dup2]
                out += [lftA+'m'+threeD[10+dup1ind-4:10+dup1ind-2]+'v'+lftB+'m'+threeD[10+dup1ind+1:10+dup1ind+3]+'v'+dup2+dup4,lftA+'m'+threeD[10+dup1ind-4:10+dup1ind-2]+'v'+lftB+'m'+threeD[10+dup1ind+1:10+dup1ind+3]+'v'+dup4+dup2] 
            if int(dup4) == int(dup2)+4:
                Dsnip = D[:dup1ind+1]+D[dup1ind+2:dup3ind+1]+D[dup3ind+2:]
                threeD = Dsnip+Dsnip+Dsnip
                dup1ind = Dsnip.index(dup2)
                rtA,rtB,lftA,lftB = threeD[10+dup1ind+1:10+dup1ind+4],threeD[10+dup1ind+6:10+dup1ind+9],threeD[10+dup1ind-2:10+dup1ind+1],threeD[10+dup1ind-7:10+dup1ind-4]
                out += [rtA+'m'+threeD[10+dup1ind+4:10+dup1ind+6]+'v'+rtB+'m'+threeD[10+dup1ind-1:10+dup1ind+1]+'v'+dup1+dup3,rtA+'m'+threeD[10+dup1ind+4:10+dup1ind+6]+'v'+rtB+'m'+threeD[10+dup1ind-1:10+dup1ind+1]+'v'+dup3+dup1]
                out += [lftA+'m'+threeD[10+dup1ind-4:10+dup1ind-2]+'v'+lftB+'m'+threeD[10+dup1ind+1:10+dup1ind+3]+'v'+dup1+dup3,lftA+'m'+threeD[10+dup1ind-4:10+dup1ind-2]+'v'+lftB+'m'+threeD[10+dup1ind+1:10+dup1ind+3]+'v'+dup3+dup1] 
                rtA,rtB,lftA,lftB = threeD[10+dup2ind+3:10+dup1ind+6],threeD[10+dup2ind-2:10+dup2ind+1],threeD[10+dup2ind+1:10+dup2ind+4],threeD[10+dup2ind-4:10+dup2ind-1]
            return out
    else:
        return []


        
# for tripods, hexapods, and degree 9 webs in SL3, identify forks connecting to boundary
def WebToForks(S):
    if len(S) == 3:
        return [S[0:2],S[1:3],S[0]+S[2]]
    elif len(S) == 8:
        return [S[0:2],S[3:5],S[6:8]]
    elif len(S) == 13:
        #        if S[0]< S[3]:
        return [[S[0:2],S[3:5]],[S[8:10],S[11:13]],S[6]]
        #else:
        #    return [[S[3:5],S[0:2]],[S[8:10],S[11:13]],S[6]]

    else:
        return []
    
# ad hoc way of testing if two Sl3 web strings are compatible    
def CompatibilityTest(S,T):
    if set([S,T]) == set(['138','17m34m56']):
        return True
    if set([S,T]) == set(['128','17m24m56']):
        return True
    k = 3
    n = 9
    xtras = DegreeToWebString([str(i) for i in range(1,10)],k,n)
    xtrasp = [str(i) + str(i+1) + str(i+2) for i in range(1,n-1)]
    xtrasp+= ['129','189']
    if (S in xtrasp) or (T in xtrasp):
        return True         
    if len(T) < len(S):
        Scopy = copy(S)
        Tcopy = copy(T)
        T = Scopy
        S = Tcopy

    if T in xtras:
        while T != '12m34v5v67m89':
            S = RotateClusterVarString(S,k,n)
            T = RotateClusterVarString(T,k,n)
        if S in ['124','125','128','134','158','159','167','267','289','348','349','356','357','457','589','679','689']:
            return True
        elif S in ['12m34m56','12m34m57','12m34m67','12m34m89','12m34m58','12m34m59','12m67m89','34m67m89','35m67m89','45m67m89','15m67m89','25m67m89']:
            return True
        elif S in ['18m67v5v12m34','19m67v5v12m34','12m34v5v29m67','12m34v5v28m67','19m34v5v67m89','18m34v5v67m89','19m34v5v67m89','29m34v5v67m89','28m34v5v67m89']:
            return True
        else:
            return False        
            
    
    if len(S) == 3 and len(T) == 3:
        Slist = [int(x) for x in S ]
        Tlist = [int(y) for y in T]
        return weakly_separated(Slist,Tlist)

    if len(S) == 3 and len(T) == 8:
        if int(T[6])>int(T[7]):
            T = T[:6]+T[7]+T[6]
        Slist = [int(x) for x in S ]
        SForks,TForks = WebToForks(S), WebToForks(T)
        TForksL = [[int(g[0]),int(g[1])] for g in TForks]
        TPlu = []
        for fork in TForksL:
            TPlu.append(fork[0])
            TPlu.append(fork[1])
        TPlu.sort()
        for f in SForks:
            for g in TForks:
                if f == g:
                    #print "they share a fork"
                    return True
        SnotT = [y for y in Slist if y not in TPlu]
        if len(SnotT) == 0:
            #print "zero length breh", Slist,TPlu
            return False
        elif len(SnotT) == 1:
            case = []
            OtherFs = []
            for i in range(3):
                if Slist[i] not in SnotT:
                    for fork in TForksL:
                        if Slist[i] in fork:                    
                            OtherFs.append([y for y in fork if y!= Slist[i]][0])
                            case.append(TForksL.index(fork))
            if case == [0,1] or case == [1,2]:
                if OtherFs[1] >SnotT[0]:
                    if (OtherFs[0] <SnotT[0]) or (OtherFs[0]>OtherFs[1]):
                        return True
            else: 
                if (OtherFs[1] < SnotT[0]) or (SnotT[0]< OtherFs[0]):
                    return True            
        else:
            #print "here", Slist,SnotT,TPLu
            return weakly_separated(Slist,TPlu)
        #print "doodlesz"
        return False
        
    elif len(S) == 8 and len(T) == 8:
        if int(T[6])>int(T[7]):
            T = T[:6]+T[7]+T[6]
        if int(S[6])>int(S[7]):
            T = S[:6]+S[7]+S[6]
        SForks,TForks = WebToForks(S), WebToForks(T)
        SForksL,TForksL = [[int(g[0]),int(g[1])] for g in SForks], [[int(g[0]),int(g[1])] for g in TForks]
        SForksPlu, TForksPlu = [],[]
        for i in range(3):
            TForksPlu += [TForksL[i][0],TForksL[i][1]]
            SForksPlu += [SForksL[i][0],SForksL[i][1]]
        if not weakly_separated(SForksPlu,TForksPlu):
            return False
        
        matches1 = [[['nope'] for j in range(3)] for i in range(3)]
        matches2 = []
        for i in range(3):
            for j in range(3):
                intn = set(TForksL[i]).intersection(set(SForksL[j]))
                if len(intn) == 2:
                    matches2.append([i,j])
                elif len(intn) == 1:
                    matches1[i][j] = 'yep'
                    
        if len(matches2) >1:
            #print "lots of overlap"
            return True
        if len(matches2) == 1:
            #print "overlap of 1"
            for i in range(3):
                if matches1[i].count('yep') == 2:
                    return False
            for j in range(3):
                temp = [matches1[i][j] for i in range(3)]
                if temp.count('yep') == 2:
                    return False
            return True     
        if len(matches2) == 0:
            #print "overlap of 0"
            for i in range(3):
                if matches1[i].count('yep') == 2 and matches1[i][1] == 'yep':
                    #print "this happened"
                    return False
            for j in range(3):                
                temp = [matches1[i][j] for i in range(3)]
                if temp.count('yep') == 2 and temp[1] == 'yep':
                    #print "this other thing happened"
                    return False
            return True
    elif len(T) == 13:
        if ((len(S) == 8) and (int(S[6])>int(S[7]))):
            S = S[:6]+S[7]+S[6]  
        SForks,TForks = WebToForks(S), WebToForks(T)
        TForks = TForks[:2]
        if len(S) == 13:
            SForks = SForks[:2]
        if len(S) == 13:
            SForksL,TForksL = [[int(h[0][0]),int(h[0][1]),int(h[1][0]),int(h[1][1])] for h in SForks], [[int(g[0][0]),int(g[0][1]),int(g[1][0]),int(g[1][1])] for g in TForks]
            if (SForksL[0] in TForksL) or (SForksL[1] in TForksL):
                return True
            else:
                return False
        SForksL,TForksL = [[int(h[0]),int(h[1])] for h in SForks], [[int(g[0][0]),int(g[0][1]),int(g[1][0]),int(g[1][1])] for g in TForks]
        TForksPlu, SForksPlu = [],[]
        for i in range(3):
            SForksPlu += [SForksL[i][0],SForksL[i][1]]
        for i in range(2):
            TForksPlu += [TForksL[i][0],TForksL[i][1],TForksL[i][2],TForksL[i][3]]
        if not weakly_separated(SForksPlu,TForksPlu):
            return False
        elif len(S) != 8:
            return True
        else:
            if ((SForksL[0]+SForksL[1]) in TForksL) or ((SForksL[0]+SForksL[2]) in TForksL) or ((SForksL[1]+SForksL[2]) in TForksL):
                return True
            else:
                return False 
    return False        



#solve an ER relation symbolically by looping over posssible cluster variables of the appropriate degree and checking using ExchangeRelnTester.
#if (k,n) == (3,9) then check the conjectural web compatibility statements using CompatbilityTester -- that is, the new cluster variable is 
#    compatible with the current cluster, and is not compatible with the web that it exchanges with.  

def ExchangeRelnParser(ERstring,k,n):
    ERExceptions = {'237x?=12m89v7v23m45x23m56m78+289x23m45m78x123x567':'12m89v23m45v56m78', '347x?=147x237x13m89v7v34m56+137x13m47m89x234x567':'13m89v7m56m17m23v4'}
    ERExceptions.update({'457x?=279x12m34v9v45m78x456+29m45m78x12m34v9v45m67':'12m34v9v(29m78)6m45'})
    #ERExceptions.update({'578x?=19m23m78x19m24m58x567+19m23m58x19m24m57x678':''})
    #ERExceptions.update({'289x?=239x34m56v2v57m89x189+34m56m89x23m57m89x129':''})
    #ERExceptions.update({'347x?=147x23m47m89x34m56m78+13m47m89x478x234x567':''})
    #ERExceptions.update({'19m23v4v67m89x?=139x467x234x678x189+18m67v4v19m23x34m67m89':''})
    #ERExceptions.update({'19m34m78x?=467x19m36m78x345x789x129+19m78v6v29m34x19m78v3v45m67':''})    
    if ERExceptions.has_key(ERstring):
        return True,ERExceptions[ERstring]
    Eqloc = ERstring.index('=')
    LHSstring = ERstring[:Eqloc-2]
    LHSlist = list(LHSstring)
    RHSstring = ERstring[Eqloc+1:]
    RHSplusloc = RHSstring.index('+')
    RHSa = RHSstring[:RHSplusloc]
    RHSb = RHSstring[RHSplusloc+1:]
    RHSanfactors = RHSa.count('x')
    RHSbnfactors = RHSb.count('x')
    RHSafactors = []
    RHSbfactors = []
    ctr = 0
    for i in range(RHSanfactors):
        ctrnew = RHSa[ctr:].index('x')
        RHSafactors.append(RHSa[ctr:ctr+ctrnew])
        ctr += ctrnew+1        
    RHSafactors.append(RHSa[ctr:])

    ctr = 0
    for i in range(RHSbnfactors):
        ctrnew = RHSb[ctr:].index('x')
        RHSbfactors.append(RHSb[ctr:ctr+ctrnew])
        ctr += ctrnew+1
    RHSbfactors.append(RHSb[ctr:])
 
    Degreea = list(RHSa)
    Degreeb = list(RHSb)        
    while LHSlist.count('m'):
        LHSlist.remove('m')
    while LHSlist.count('v'):
        LHSlist.remove('v')
    while Degreea.count('m'):
        Degreea.remove('m')
    while Degreea.count('x'):
        Degreea.remove('x')
    while Degreea.count('v'):
        Degreea.remove('v')
    while Degreeb.count('m'):
        Degreeb.remove('m')
    while Degreeb.count('x'):
        Degreeb.remove('x')
    while Degreeb.count('v'):
        Degreeb.remove('v')

    for symbol in LHSlist:
        if Degreea.count(symbol):
            Degreea.remove(symbol)
        if Degreeb.count(symbol):
            Degreeb.remove(symbol)
    #Degreea.sort()
    #Degreeb.sort()
    #assert Degreea == Degreeb
    ClusterVarsByDegree = DegreeToWebString(Degreea,k,n)
    for S in ClusterVarsByDegree:
        Scop = copy(S)
        LHScop = copy(LHSstring)
        if k==3:
            out = str()
            incompatibilityflag = 0
            for T in RHSafactors+ RHSbfactors:
                Tcop = copy(T)
                if CompatibilityTest(Scop,Tcop):
                    continue
                else:
                    #print S,T,"failed"
                    incompatibilityflag = 1
                    break
                if CompatibilityTest(Scop,LHScop):
                    #print S,T,"failed"
                    incompatibilityflag =1
                    break
            if incompatibilityflag == 0:
                out = S
                minusout = S[:len(S)-2]+S[len(S)-1]+S[len(S)-2]
                #print "success",out,minusout
                if ExchangeRelnTester(LHSstring+'x'+out+'='+RHSstring,k,n):
                    return True,out
                elif ExchangeRelnTester(LHSstring+'x'+minusout+'='+RHSstring,k,n):
                    return True,minusout
                else:
                    return False,'NAN'            
        elif k==4:
            if ExchangeRelnTester(LHSstring+'x'+S+'='+RHSstring,k,n):
                return True,S
    Degreea.sort()
    return False,'NAN'                


#Check symbolic exchange relns by comparing the left and right hand side as polynomials
def ExchangeRelnTester(ERstring,k,n):
    Eqloc = ERstring.index('=')
    LHSstring = ERstring[:Eqloc]
    LHSxloc = LHSstring.index('x')
    LHS = MonomialSum(k,n,LHSstring[:LHSxloc])*MonomialSum(k,n,LHSstring[LHSxloc+1:])
    RHSstring = ERstring[Eqloc+1:]
    RHSplusloc = RHSstring.index('+')
    RHSa = RHSstring[:RHSplusloc]
    RHSb = RHSstring[RHSplusloc+1:]
    RHSanfactors = RHSa.count('x')
    RHSbnfactors = RHSb.count('x')
    ctr = 0
    RHSamonom = MonomialSum(k,n,[])+1
    RHSbmonom = MonomialSum(k,n,[])+1
    for i in range(RHSanfactors):
        ctrnew = RHSa[ctr:].index('x')
        RHSamonom *= MonomialSum(k,n,RHSa[ctr:ctr+ctrnew])
        ctr += ctrnew+1        
    RHSamonom *= MonomialSum(k,n,RHSa[ctr:])    
    ctr = 0

    for i in range(RHSbnfactors):
        ctrnew = RHSb[ctr:].index('x')
        RHSbmonom *= MonomialSum(k,n,RHSb[ctr:ctr+ctrnew])
        ctr += ctrnew+1        
    RHSbmonom *= MonomialSum(k,n,RHSb[ctr:])
    return LHS == RHSamonom+RHSbmonom




def NumericalClusterVariable(SS,M):
    k,n = M.nrows(),M.ncols()
    monomialsum = QQ.zero()
    if SS == None:
        a = 2
    elif (k,n) == (3,9):
        xes = [0]+[M[0,i] for i in range(9)]
        yes = [0]+[M[1,i] for i in range(9)]
        zes = [0]+[M[2,i] for i in range(9)]
        if len(SS) == 3:
            S = list(SS)
            Slist = [int(s) for s in S]
            Slist.sort()
            for p in [[0,1,2],[2,0,1],[1,2,0]]:
                monomialsum += xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]
            for p in [[1,0,2],[2,1,0],[0,2,1]]:
                monomialsum -= xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]
        elif len(SS) == 8:
            S = WebToForks(SS)
            S.sort()
            monomialsum += NumericalClusterVariable(S[0]+S[1][1:],M)*NumericalClusterVariable(S[1][:1]+S[2],M)
            if monomialsum == 0:
                monomialsum += NumericalClusterVariable(S[0]+S[1][:1],M)*NumericalClusterVariable(S[1][1:]+S[2],M)
            else: 
                monomialsum -= NumericalClusterVariable(S[0]+S[1][:1],M)*NumericalClusterVariable(S[1][1:]+S[2],M)
        elif len(SS) == 13:  
            S = WebToForks(SS)
            firstguessa = [int(S[2]),int(S[0][0][0]),int(S[0][0][1])]
            firstguessb = [int(S[0][1][0]),int(S[0][1][1]),int(S[1][0][0]),int(S[1][0][1]),int(S[1][1][0]),int(S[1][1][1])]
            firstguessc = [int(S[2]),int(S[0][1][0]),int(S[0][1][1])]
            firstguessd = [int(S[0][0][0]),int(S[0][0][1]),int(S[1][0][0]),int(S[1][0][1]),int(S[1][1][0]),int(S[1][1][1])]
            if not weakly_separated(firstguessa,firstguessb):
                monomialsum = NumericalClusterVariable(S[2]+S[0][0],M)*NumericalClusterVariable(S[0][1]+'m'+S[1][0]+'m'+S[1][1],M)-NumericalClusterVariable(S[2]+S[0][1],M)*NumericalClusterVariable(S[0][0]+'m'+S[1][0]+'m'+S[1][1],M)
            else:
                assert not weakly_separated(firstguessc,firstguessd)
                monomialsum = NumericalClusterVariable(S[2]+S[0][1],M)*NumericalClusterVariable(S[0][0]+'m'+S[1][0]+'m'+S[1][1],M)-NumericalClusterVariable(S[2]+S[0][0],M)*NumericalClusterVariable(S[0][1]+'m'+S[1][0]+'m'+S[1][1],M)
        elif SS == '13m89v7m56m17m23v4':
            monomialsum = NumericalClusterVariable('147',M)*NumericalClusterVariable('13m89v7v23m56',M)-NumericalClusterVariable('234',M)*NumericalClusterVariable('567',M)*NumericalClusterVariable('189',M)*NumericalClusterVariable('137',M)
        elif SS == '12m89v23m45v56m78':
            monomialsum = NumericalClusterVariable('12m56m89',M)*NumericalClusterVariable('23m45m78',M)-NumericalClusterVariable('235',M)*NumericalClusterVariable('456',M)*NumericalClusterVariable('128',M)*NumericalClusterVariable('789',M)

    elif (k,n) == (4,8):
        xes = [0]+[M[0,i] for i in range(8)]
        yes = [0]+[M[1,i] for i in range(8)]
        zes = [0]+[M[2,i] for i in range(8)]
        wes = [0]+[M[3,i] for i in range(8)]        
        if len(SS) ==4:
            S = list(SS)
            Slist = [int(s) for s in S]
            #Slist.sort()
            for p in [[0,1,2,3],[2,0,1,3],[1,2,0,3],[0,3,1,2],[2,3,0,1],[1,3,2,0],[1,0,3,2],[2,1,3,0],[0,2,3,1],[3,1,0,2],[3,2,1,0],[3,0,2,1]]:
                monomialsum += xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]*wes[Slist[p[3]]]
            for p in [[1,0,2,3],[2,1,0,3],[0,2,1,3],[1,3,0,2],[2,3,1,0],[0,3,2,1],[0,1,3,2],[2,0,3,1],[1,2,3,0],[3,0,1,2],[3,2,0,1],[3,1,2,0]]:
                monomialsum -= xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]*wes[Slist[p[3]]]
        elif len(SS) == 10:  #ABCmDEFvGH 0..2,4..6,89
            S = SS
            monomialsum += NumericalClusterVariable(S[0]+S[4:7],M)*NumericalClusterVariable(S[1:3]+S[8:],M)-NumericalClusterVariable(S[1]+S[4:7],M)*NumericalClusterVariable(S[0]+S[2]+S[8:],M)+NumericalClusterVariable(S[2]+S[4:7],M)*NumericalClusterVariable(S[:2]+S[8:],M)
        elif len(SS) == 16: #ABCmDEvFGHmIJvKL 0..2,4..5,7..9,11..12,14..15        
            S = SS        
            monomialsum += NumericalClusterVariable(S[:2]+S[4:6],M)*NumericalClusterVariable(S[7:9]+S[11:13],M)*NumericalClusterVariable(S[2]+S[9]+S[14:],M)-NumericalClusterVariable(S[:2]+S[4:6],M)*NumericalClusterVariable(S[7]+S[9]+S[11:13],M)*NumericalClusterVariable(S[2]+S[8]+S[14:],M)+NumericalClusterVariable(S[:2]+S[4:6],M)*NumericalClusterVariable(S[8:10]+S[11:13],M)*NumericalClusterVariable(S[2]+S[7]+S[14:],M)
            monomialsum -= NumericalClusterVariable(S[0]+S[2]+S[4:6],M)*NumericalClusterVariable(S[7:9]+S[11:13],M)*NumericalClusterVariable(S[1]+S[9]+S[14:],M)-NumericalClusterVariable(S[0]+S[2]+S[4:6],M)*NumericalClusterVariable(S[7]+S[9]+S[11:13],M)*NumericalClusterVariable(S[1]+S[8]+S[14:],M)+NumericalClusterVariable(S[0]+S[2]+S[4:6],M)*NumericalClusterVariable(S[8:10]+S[11:13],M)*NumericalClusterVariable(S[1]+S[7]+S[14:],M)
            monomialsum += NumericalClusterVariable(S[1:3]+S[4:6],M)*NumericalClusterVariable(S[7:9]+S[11:13],M)*NumericalClusterVariable(S[0]+S[9]+S[14:],M)-NumericalClusterVariable(S[1:3]+S[4:6],M)*NumericalClusterVariable(S[7]+S[9]+S[11:13],M)*NumericalClusterVariable(S[0]+S[8]+S[14:],M)+NumericalClusterVariable(S[1:3]+S[4:6],M)*NumericalClusterVariable(S[8:10]+S[11:13],M)*NumericalClusterVariable(S[0]+S[7]+S[14:],M)
    return monomialsum

    
    
def MonomialSum(k,n,SS):
    # bogus change if (k,n) == (3,9):   
    if k==3:   
        x1,x2,x3,x4,x5,x6,x7,x8,x9,y1,y2,y3,y4,y5,y6,y7,y8,y9,z1,z2,z3,z4,z5,z6,z7,z8,z9 = ZZ['x1,x2,x3,x4,x5,x6,x7,x8,x9,y1,y2,y3,y4,y5,y6,y7,y8,y9,z1,z2,z3,z4,z5,z6,z7,z8,z9'].gens() 
        xes = [0,x1,x2,x3,x4,x5,x6,x7,x8,x9]
        yes = [0,y1,y2,y3,y4,y5,y6,y7,y8,y9]
        zes = [0,z1,z2,z3,z4,z5,z6,z7,z8,z9]
        monomialsum = 0*x1
        if SS == None:
            a = 2
        elif len(SS) == 3:
            S = list(SS)
            Slist = [int(s) for s in S]
            Slist.sort()
            for p in [[0,1,2],[2,0,1],[1,2,0]]:
                monomialsum += xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]
            for p in [[1,0,2],[2,1,0],[0,2,1]]:
                monomialsum -= xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]
        elif len(SS) == 8:
            S = WebToForks(SS)
            S.sort()
            monomialsum += MonomialSum(k,n,S[0]+S[1][1:])*MonomialSum(k,n,S[1][:1]+S[2])
            if monomialsum == 0:
                monomialsum += MonomialSum(k,n,S[0]+S[1][:1])*MonomialSum(k,n,S[1][1:]+S[2])
            else: 
                monomialsum -= MonomialSum(k,n,S[0]+S[1][:1])*MonomialSum(k,n,S[1][1:]+S[2])
        elif len(SS) == 13:  
            S = WebToForks(SS)
            firstguessa = [int(S[2]),int(S[0][0][0]),int(S[0][0][1])]
            firstguessb = [int(S[0][1][0]),int(S[0][1][1]),int(S[1][0][0]),int(S[1][0][1]),int(S[1][1][0]),int(S[1][1][1])]
            firstguessc = [int(S[2]),int(S[0][1][0]),int(S[0][1][1])]
            firstguessd = [int(S[0][0][0]),int(S[0][0][1]),int(S[1][0][0]),int(S[1][0][1]),int(S[1][1][0]),int(S[1][1][1])]
            if not weakly_separated(firstguessa,firstguessb):
                monomialsum = MonomialSum(k,n,S[2]+S[0][0])*MonomialSum(k,n,S[0][1]+'m'+S[1][0]+'m'+S[1][1])-MonomialSum(k,n,S[2]+S[0][1])*MonomialSum(k,n,S[0][0]+'m'+S[1][0]+'m'+S[1][1])
            else:
                assert not weakly_separated(firstguessc,firstguessd)
                monomialsum = MonomialSum(k,n,S[2]+S[0][1])*MonomialSum(k,n,S[0][0]+'m'+S[1][0]+'m'+S[1][1])-MonomialSum(k,n,S[2]+S[0][0])*MonomialSum(k,n,S[0][1]+'m'+S[1][0]+'m'+S[1][1])
        elif SS == '13m89v7m56m17m23v4':
            monomialsum = MonomialSum(k,n,'147')*MonomialSum(k,n,'13m89v7v23m56')-MonomialSum(k,n,'234')*MonomialSum(k,n,'567')*MonomialSum(k,n,'189')*MonomialSum(k,n,'137')
        elif SS == '12m89v23m45v56m78':
            monomialsum = MonomialSum(k,n,'12m56m89')*MonomialSum(k,n,'23m45m78')-MonomialSum(k,n,'235')*MonomialSum(k,n,'456')*MonomialSum(k,n,'128')*MonomialSum(k,n,'789')

    elif (k,n) == (4,8):
        x1,x2,x3,x4,x5,x6,x7,x8,y1,y2,y3,y4,y5,y6,y7,y8,z1,z2,z3,z4,z5,z6,z7,z8,w1,w2,w3,w4,w5,w6,w7,w8 = ZZ['x1,x2,x3,x4,x5,x6,x7,x8,y1,y2,y3,y4,y5,y6,y7,y8,z1,z2,z3,z4,z5,z6,z7,z8,w1,w2,w3,w4,w5,w6,w7,w8'].gens() 
        xes = [0,x1,x2,x3,x4,x5,x6,x7,x8]
        yes = [0,y1,y2,y3,y4,y5,y6,y7,y8]
        zes = [0,z1,z2,z3,z4,z5,z6,z7,z8]
        wes = [0,w1,w2,w3,w4,w5,w6,w7,w8]
        monomialsum = 0*x1
        if SS == None:
            a = 2
        if len(SS) ==4:
            S = list(SS)
            Slist = [int(s) for s in S]
            #Slist.sort()
            for p in [[0,1,2,3],[2,0,1,3],[1,2,0,3],[0,3,1,2],[2,3,0,1],[1,3,2,0],[1,0,3,2],[2,1,3,0],[0,2,3,1],[3,1,0,2],[3,2,1,0],[3,0,2,1]]:
                monomialsum += xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]*wes[Slist[p[3]]]
            for p in [[1,0,2,3],[2,1,0,3],[0,2,1,3],[1,3,0,2],[2,3,1,0],[0,3,2,1],[0,1,3,2],[2,0,3,1],[1,2,3,0],[3,0,1,2],[3,2,0,1],[3,1,2,0]]:
                monomialsum -= xes[Slist[p[0]]]*yes[Slist[p[1]]]*zes[Slist[p[2]]]*wes[Slist[p[3]]]
        elif len(SS) == 10:  #ABCmDEFvGH 0..2,4..6,89
            S = SS
            monomialsum += MonomialSum(k,n,S[0]+S[4:7])*MonomialSum(k,n,S[1:3]+S[8:])-MonomialSum(k,n,S[1]+S[4:7])*MonomialSum(k,n,S[0]+S[2]+S[8:])+MonomialSum(k,n,S[2]+S[4:7])*MonomialSum(k,n,S[:2]+S[8:])
        elif len(SS) == 16: #ABCmDEvFGHmIJvKL 0..2,45,7..9,11 12,14 15
            S = SS        
            monomialsum += MonomialSum(k,n,S[:2]+S[4:6])*MonomialSum(k,n,S[7:9]+S[11:13])*MonomialSum(k,n,S[2]+S[9]+S[14:])-MonomialSum(k,n,S[:2]+S[4:6])*MonomialSum(k,n,S[7]+S[9]+S[11:13])*MonomialSum(k,n,S[2]+S[8]+S[14:])+MonomialSum(k,n,S[:2]+S[4:6])*MonomialSum(k,n,S[8:10]+S[11:13])*MonomialSum(k,n,S[2]+S[7]+S[14:])
            monomialsum -= MonomialSum(k,n,S[0]+S[2]+S[4:6])*MonomialSum(k,n,S[7:9]+S[11:13])*MonomialSum(k,n,S[1]+S[9]+S[14:])-MonomialSum(k,n,S[0]+S[2]+S[4:6])*MonomialSum(k,n,S[7]+S[9]+S[11:13])*MonomialSum(k,n,S[1]+S[8]+S[14:])+MonomialSum(k,n,S[0]+S[2]+S[4:6])*MonomialSum(k,n,S[8:10]+S[11:13])*MonomialSum(k,n,S[1]+S[7]+S[14:])
            monomialsum += MonomialSum(k,n,S[1:3]+S[4:6])*MonomialSum(k,n,S[7:9]+S[11:13])*MonomialSum(k,n,S[0]+S[9]+S[14:])-MonomialSum(k,n,S[1:3]+S[4:6])*MonomialSum(k,n,S[7]+S[9]+S[11:13])*MonomialSum(k,n,S[0]+S[8]+S[14:])+MonomialSum(k,n,S[1:3]+S[4:6])*MonomialSum(k,n,S[8:10]+S[11:13])*MonomialSum(k,n,S[0]+S[7]+S[14:])
        elif ((len(SS) == 15) and (SS[7]=='v')): #ABCmDEvFGHmIJ  012,456,8910,121314
            S = SS
            monomialsum+=MonomialSum(k,n,S[0]+S[4:7])*MonomialSum(k,n,S[1]+S[2]+S[9:11])*MonomialSum(k,n,S[8]+S[12:])-MonomialSum(k,n,S[1]+S[4:7])*MonomialSum(k,n,S[0]+S[2]+S[9:11])*MonomialSum(k,n,S[8]+S[12:])+MonomialSum(k,n,S[2]+S[4:7])*MonomialSum(k,n,S[0]+S[1]+S[9:11])*MonomialSum(k,n,S[8]+S[12:]) 
            monomialsum-=MonomialSum(k,n,S[0]+S[4:7])*MonomialSum(k,n,S[1]+S[2]+S[8]+S[10])*MonomialSum(k,n,S[9]+S[12:])-MonomialSum(k,n,S[1]+S[4:7])*MonomialSum(k,n,S[0]+S[2]+S[8]+S[10])*MonomialSum(k,n,S[9]+S[12:])+MonomialSum(k,n,S[2]+S[4:7])*MonomialSum(k,n,S[0]+S[1]+S[8]+S[10])*MonomialSum(k,n,S[9]+S[12:])
            monomialsum-=MonomialSum(k,n,S[0]+S[4:7])*MonomialSum(k,n,S[1]+S[2]+S[8:10])*MonomialSum(k,n,S[10]+S[12:])-MonomialSum(k,n,S[1]+S[4:7])*MonomialSum(k,n,S[0]+S[2]+S[8:10])*MonomialSum(k,n,S[10]+S[12:])+MonomialSum(k,n,S[2]+S[4:7])*MonomialSum(k,n,S[0]+S[1]+S[8:10])*MonomialSum(k,n,S[10]+S[12:])
    else:
        print 'here',k,n
        return False
    return monomialsum

    
    
    
    


# input symbolic clusters on FD, return their numerical values 
def MakeNClusters(clusters,M):
    return [[NumericalClusterVariable(x,M) for x in cluster] for cluster in clusters]


########## apply CMG operations to a matrix ################## 
def NumericallyRotateMatrix(M):
    n = M.ncols()
    N = M.matrix_from_columns(range(1,n)+[0])
    if n == 8:
        N[:,7] = -N[:,7]
    return N

def CrossProduct(v,w):
    return v[1]*w[2]-v[2]*w[1],v[2]*w[0]-v[0]*w[2],v[0]*w[1]-v[1]*w[0]

def HodgeProduct(N):
    return Matrix(4,1,[N.matrix_from_rows([1,2,3]).determinant(),N.matrix_from_rows([0,2,3]).determinant(),N.matrix_from_rows([0,1,3]).determinant(),N.matrix_from_rows([0,1,2]).determinant()])
    
    
def NumericallyTwistMatrix(M):
    N = copy(M.parent().zero_matrix())
    k = M.nrows()
    if k==3:
        for i in range(2,9):
            N[0,i],N[1,i],N[2,i] = CrossProduct(M[:,i-2],M[:,i-1])
        N[0,0],N[1,0],N[2,0] = CrossProduct(M[:,7],M[:,8])
        N[0,1],N[1,1],N[2,1] = CrossProduct(M[:,8],M[:,0])
    if k==4:
        N[:,0] = HodgeProduct(M.matrix_from_columns([5,7,6]))
        N[:,1] = HodgeProduct(M.matrix_from_columns([0,6,7]))
        N[:,2] = HodgeProduct(M.matrix_from_columns([7,1,0]))
        for i in range(3,8):
            N[:,i] = HodgeProduct(M.matrix_from_columns([i-3,i-2,i-1]))
    return N        
        


def NumericallyFGRotateMatrix(M):
    assert M.nrows() ==3
    N = copy(M.parent().zero_matrix())
    N[:,0] = copy(M[:,2])
    N[:,3] = copy(M[:,5])
    N[:,6] = copy(M[:,8])
    N[:,2] = copy(M[:,3])
    N[:,5] = copy(M[:,6])
    N[:,8] = copy(M[:,0])
    N[0,1],N[1,1],N[2,1] = CrossProduct(CrossProduct(M[:,1],M[:,2]),CrossProduct(M[:,3],M[:,4]))
    N[0,4],N[1,4],N[2,4] = CrossProduct(CrossProduct(M[:,4],M[:,5]),CrossProduct(M[:,6],M[:,7])) 
    N[0,7],N[1,7],N[2,7] = CrossProduct(CrossProduct(M[:,7],M[:,8]),CrossProduct(M[:,0],M[:,1]))   
    return N

def Sigma1(M):
    N = copy(M.parent().zero_matrix())
    a,b,c,d = NumericalClusterVariable('1345',M),NumericalClusterVariable('2345',M),NumericalClusterVariable('1578',M),NumericalClusterVariable('1678',M)
    N[:,0] = copy(M[:,1])
    N[:,2] = copy(M[:,2])
    N[:,3] = copy(M[:,3])
    N[:,4] = copy(M[:,5])
    N[:,6] = copy(M[:,6])
    N[:,7] = copy(M[:,7])
    N[:,1] = copy(a*M[:,1]-b*(M[:,0]))
    N[:,5] = copy(c*M[:,5]-d*(M[:,4]))
    return N

def Sigma2(M):
    N = copy(M.parent().zero_matrix())
    a,b,c,d = NumericalClusterVariable('2456',M),NumericalClusterVariable('3456',M),NumericalClusterVariable('6812',M),NumericalClusterVariable('7812',M)
    N[:,0] = copy(M[:,0])
    N[:,1] = copy(M[:,2])
    N[:,3] = copy(M[:,3])
    N[:,4] = copy(M[:,4])
    N[:,5] = copy(M[:,6])
    N[:,7] = copy(M[:,7])
    N[:,2] = copy(a*M[:,2]-b*(M[:,1]))
    N[:,6] = copy(c*M[:,6]-d*(M[:,5]))
    return N

def Sigma3(M):
    N = copy(M.parent().zero_matrix())
    a,b,c,d = NumericalClusterVariable('3567',M),NumericalClusterVariable('4567',M),NumericalClusterVariable('1237',M),NumericalClusterVariable('1238',M)
    N[:,0] = copy(M[:,0])
    N[:,1] = copy(M[:,1])
    N[:,2] = copy(M[:,3])
    N[:,4] = copy(M[:,4])
    N[:,5] = copy(M[:,5])
    N[:,6] = copy(M[:,7])
    N[:,3] = copy(a*M[:,3]-b*(M[:,2]))
    N[:,7] = copy(c*M[:,7]-d*(M[:,6]))
    return N
    
def Sigma21(M):
    return Sigma2(Sigma1(M))

def Sigma212(M):
    return Sigma2(Sigma1(Sigma2(M)))
    
def RotateClusterVarString(S,k,n,nrots = 1):
    if S == None:
        return '123'
    ctr = 0
    while ctr < nrots:
        out_string = []
        for x in list(S):
            if x == 'm' or x == 'v':
                3*2
            else: 
                out_string.append(str(int(x)+1))
        Out = DegreeToWebString(out_string,k,n)
        if len(S) == k:
            S = list(Out[0])
        if len(S) == 2*k+2:
            for x in Out:
                if S[1] != str(n):
                    strrr = str(int(S[0])+1)+str(int(S[1])+1)
                    if x.count(strrr):
                        break
                else: 
                    strrr = '1'+str(int(S[0])+1)
                    if x.count(strrr):
                        break
                
            S = list(x)

        if len(S) == 3*k+4:
            Sstr = str().join(S)
            for i in range(1,n+1):                
                if Sstr.count('v'+ str(i) + 'v'):
                    for x in Out:
                        if x.count('v'+ str(i+1) + 'v'):
                            S = list(x)
                        if x.count('v' + str(1)+ 'v'):
                            if Sstr.count('v' + str(n)+ 'v'):
                                S = list(x)
        
        if len(S) not in [3,8,13]:
            print "no method for rotating", S, "input the rotated version"
            return input()                    
        ctr +=1   
    return str().join(S)
        

    


        
############## Fundamental Domain class
    
class Fundamental_Domain(SageObject):
    def __init__(self,k,n):
        self._frozen_list = [sorted([x%n+1 for x in range(i,i+k)]) for i in range(n)]
        self._k = k
        self._n  = n
        self._cluster_size = (k-1)*(n-k-1)    
        self._InitialCluster = WeaklySeparatedCollection(self.InitialCluster()+self._frozen_list,self._n)
        self._Q0tilde = ClusterQuiver(matrix(self._InitialCluster.quiver()))
        self._Q0 = MutableSubquiver(self._Q0tilde,self._cluster_size)
        TS = self._Q0.mutation_class(up_to_equivalence = True, return_paths = True, show_depth = False)
        self._nQuivers = len(TS)
        print "finished finding all ", self._nQuivers, " quivers"         
        self._QuiversList = []
        self._mQuiversList = []
        self._QuiversPaths = [y[1] for y in TS]
        self._QGraph = Graph(self._nQuivers)
        #self._QLoopGraph = Graph(self._nQuivers)
        ctr = 0
        for p in self._QuiversPaths:
            Q0 = ClusterQuiver(self._Q0tilde)
            Q0.mutate(p)
            self._QuiversList.append(Q0)
            self._mQuiversList.append(MutableSubquiver(Q0,self._cluster_size))
            neighbor = self._QuiversPaths.index(p[:len(p)-1])
            self._QGraph.add_edge([ctr,neighbor])
            ctr +=1
        print "created the mutation tree", self._QGraph
        #ctr = 0
        #for Q in self._mQuiversList:
        #    for i in range(self._cluster_size):
        #        Q1 = ClusterQuiver(Q)
        #        Q1.mutate(i)
        #        neighbori = Find_equivalent(Q1,self._mQuiversList)
        #        self._QLoopGraph.add_edge([ctr,neighbori])
        #    ctr +=1 
        #print "created the full mutation graph", self._QLoopGraph


    #builds a list; each entry is a cluster on the fundamental domain 
    def Clusters(self,depth = 1000):
        print "building the clusters on the domain"
        allrels = []
        CVstring = ['NAN' for i in range(self._nQuivers)]
        QP = self._QuiversPaths
        QL = self._QuiversList
        G = self._QGraph
        #GLoop = self._QLoopGraph
        CC = self._InitialCluster._collection
        cluster_size = self._cluster_size
        CV0string = [str().join([str(x) for x in y]) for y in CC]
        clusters = [copy(CV0string) for i in range(self._nQuivers)]
        ctr = 0
        for i in range(self._nQuivers):
            CurrentCVs = copy(CV0string)
            mutated_list = []
            for j in QP[i]:
                mutated_list.append(j)
                jindex = QP.index(mutated_list)
                if jindex:
                    CurrentCVs[j] = CVstring[jindex]
                   
                   
            flagflag = 0      

            if len(QP[i]) < depth:
                Neighbors = G.neighbors(i)
                for ne in [j for j in Neighbors if j >i]:
                    clusters[ne] = copy(clusters[i]) 
                    assert len(QP[ne]) == len(QP[i])+1
                    direction = QP[ne][len(QP[i])]
                    plusstr = str()
                    minusstr = str() 
                    columnvec = QL[i].b_matrix().transpose()[direction]
                    for x in range(cluster_size+self._n):
                        if columnvec[x] == 1:
                            plusstr+= CurrentCVs[x]+ 'x'
                        elif columnvec[x] == -1:
                            minusstr += CurrentCVs[x]+ 'x'
                        elif columnvec[x] == 2:
                            plusstr += CurrentCVs[x] + 'x' + CurrentCVs[x] + 'x'
                            flagflag = 1
                        elif columnvec[x] == -2:
                            minusstr += CurrentCVs[x] + 'x' + CurrentCVs[x] + 'x'
                            flagflag = 1
                    ERstring = CurrentCVs[direction]+'x?='+plusstr[:len(plusstr)-1]+ '+' + minusstr[:len(minusstr)-1]
                    #print "round ",ctr,"relation ",ERstring
                    answer,NewCV = ExchangeRelnParser(ERstring,self._k,self._n)
                    print "next cv is ",NewCV
                    assert answer
                    CVstring[ne] = NewCV
                    clusters[ne][direction] = NewCV
                    if flagflag:
                        return (QL[i],clusters)
                    ctr +=1
                    
                    #if answer:
                    #    CVstring[ne] = NewCV
                    #    clusters[ne][direction] = NewCV
                    #    ctr +=1
                    #else:
                    #    CVstring[ne] = NewCV
                    #    clusters[ne][direction] = NewCV
                    #    ctr +=1
                    #    #print ERstring
                    #CVstring[ne] = input('what is the new cluster variable ')                      
                    #clusters[ne][direction] = CVstring[ne]
        print "successfully built the clusters on the domain. every cluster variable is a web with a tree form"    
        return clusters

                        
    
 
    def InitialCluster(self):
        k = self._k
        n = self._n
        InitialClusterList = []
        for a in range(1,n-k):
            for b in range(n-a,n-a+2):
                for k1 in range(0,k-1):
                    k2 = k-2-k1
                    if a+k1 < b-1:
                        if b+k2 < n:
                            InitialClusterList.append(range(a,a+k1+1)+range(b,b+k2+1))
                        if b+k2 ==n and a>1:
                            InitialClusterList.append(range(a,a+k1+1)+range(b,b+k2+1))
        return InitialClusterList



    def CVTaxonomy(self,CVstring = [],depth = 15):
        allrels = []
        if len(CVstring) == 0:
            CVstring = ['NAN' for i in range(self._nQuivers)]
        QP = self._QuiversPaths
        QL = self._QuiversList
        G = self._QGraph
        CC = self._InitialCluster._collection
        cluster_size = self._cluster_size
        CV0string = [str().join([str(x) for x in y]) for y in CC]
        for i in range(self._nQuivers):
            CurrentCVs = copy(CV0string)
            mutated_list = []
            for j in QP[i]:
                mutated_list.append(j)
                jindex = QP.index(mutated_list)
                if jindex:
                    CurrentCVs[j] = CVstring[jindex]
            #print 'current cluster', CurrentCVs[:cluster_size]
            if len(QP[i]) < depth:
                Neighbors = G.neighbors(i)
                for ne in [j for j in Neighbors if j >i]:
                    assert len(QP[ne]) == len(QP[i])+1
                    direction = QP[ne][len(QP[i])]
                    plusstr = str()
                    minusstr = str() 
                    columnvec = QL[i].b_matrix().transpose()[direction]
                    for x in range(cluster_size+self._n):
                        if columnvec[x] == 1:
                            plusstr+= CurrentCVs[x]+ 'x'
                        elif columnvec[x] == -1:
                            minusstr += CurrentCVs[x]+ 'x'
                        elif columnvec[x] == 2:
                            plusstr += CurrentCVs[x] + 'x' + CurrentCVs[x] + 'x'
                            print "WE hit a double arrow"
                        elif columnvec[x] == -2:
                            print "We hit a double arrow"
                            minusstr += CurrentCVs[x] + 'x' + CurrentCVs[x] + 'x'
                    ERstring = CurrentCVs[direction]+'x?='+plusstr[:len(plusstr)-1]+ '+' + minusstr[:len(minusstr)-1]
                    answer,NewCV = ExchangeRelnParser(ERstring,self._k,self._n)
                    if answer:
                        CVstring[ne] = NewCV
                        allrels.append(ERstring)
                        #if len(NewCV) != 3:   bogus change
                        #    allrels.append(ERstring)
                    else:
                        if ERstring == '237x?=12m89v7v23m45x23m56m78+289x23m45m78x123x567':
                            NewCV = '12m89v23m45v56m78'
                        elif ERstring == '347x?=147x237x13m89v7v34m56+137x13m47m89x234x567':
                            NewCV = '13m89v7m56m17m23v4'
                        elif NewCV == []:
                            print i, ne, direction, QP[i],QP[ne]
                            print ERstring 
                            CVstring[ne] = input('what is the new cluster variable ')                      
                        else:
                            print i, ne, direction, QP[i],QP[ne]
                            print ERstring 
                            print "chose from:", NewCV
                            CVstring[ne] = NewCV[input('what is the new cluster variable ')]
        allrels = list(set(allrels))
        print 'number of relations is', len(allrels)
        return allrels 
         
        CVstring = CVstring[1:]
        CVstring = CV0string[:cluster_size]+CVstring
        CVstring = list(set(CVstring))
        assert CVstring.count('NAN') == 0
        print 'found', len(CVstring), 'cluster variables'
        CVstringreturn = []
        for cv in range(len(CVstring)):
            orbit = [cv]
            cvstr = CVstring[cv]
            for nrots in range(0,self._n-1):
                cvstr = RotateClusterVarString(cvstr,self._k,self._n)
                if cvstr in CVstring:
                    orbit.append(CVstring.index(cvstr))
            orbit.sort()
            if CVstring[orbit[0]] in CVstringreturn:
                continue
            else:
                #print cv, CVstring[cv],orbit,CVstring[orbit[0]]
                CVstringreturn.append(CVstring[orbit[0]])
        print len(CVstringreturn), 'up to rotation'
        return CVstringreturn
                
            
               

        

        


########################################################################        
# Some basic operations on sets                
            


def listminus(ll,e):
    return list(set(ll)-{e})	
	
def listcomplement(ll,ss):
    return list(set(ll)-set(ss))

def weakly_separated(S,T):
    S.sort()
    T.sort()
    if len(S)*len(T):
        n = max(max(S),max(T))
    else:
        return True
    switches, sgn = 0,0

    for i in range(1,n+1):
        if i in S:
            if i in T:
                continue
            else:
                if sgn in [0,-1]:
                    switches +=1
                sgn = 1
        elif i in T:
            if sgn in [0,1]:
                switches += 1
            sgn = -1
    if switches <4:
        return True
    else:
        return False







########### Weakly Separated Collection Class
class WeaklySeparatedCollection(SageObject):
    def __init__(self,CC,n):
        self._collection = CC
        self._size = len(CC)
        self._k = len(CC[0])
        self._n = n
        CCdict = {}
        ctr = 0
        for S in CC:
            CCdict[tuple(S)] = ctr
            ctr+= 1
        self._dictionary = CCdict

    def collection_to_dictionary(self):		
        CC = self._collection
        CCdict = {}
        ctr = 0
        for S in CC:
            CCdict[tuple(S)] = ctr
            ctr+= 1
        self._dictionary = CCdict

    def is_maximal(self):
        return (self._size == (self._k)*(self._n-self._k)+1)
	
		
    def extend_to_maximal(self):
        n = self._n
        k = self._k
        CC = self._collection
        SS = sorted([list(x) for x in Subsets(range(1,n+1),k)])
        SSnew = copy(SS)
        for X in SS:
            for Y in CC:
                if X == Y or (not weakly_separated(X,Y)):  
                    SSnew.remove(X)
                    break
        SS = copy(SSnew)
        while len(SS):
            S = SS[0]
            self._collection.append(S)
            SSnew = copy(SS)
            for X in SS:
                if X == S or (not weakly_separated(X,S)):  
                    SSnew.remove(X)
            SS = copy(SSnew)
        self.frozens_at_end()
        self.collection_to_dictionary()	
        self._size = len(self._collection)
	
    def frozens_at_end(self):
        k = self._k
        n = self._n
        frozen_list = [sorted([x%n+1 for x in range(i,i+k)]) for i in range(n)]
        CC = copy(self._collection)
        for x in frozen_list:
            CC.append(CC.pop(CC.index(x)))
        self._collection = copy(CC)
        self.collection_to_dictionary()



    def white_black_cliques(self):
        self.frozens_at_end()
        n = self._n
        CC = self._collection
        WW = []
        for C in CC:
            for i in C:
                K = sorted(listminus(C,i))
                if K not in WW:
                    WW.append(K)
        BB = []
        for C in CC:
            for i in listcomplement(range(1,n+1), C):
                K = sorted(C+[i])
                if K not in BB:
                    BB.append(K)
        return WW, BB	


    def quiver(self):
        k = self._k
        n = self._n		
        NN = self._size
        CC = self._collection
        CCdict = self._dictionary		
        WW, BB = self.white_black_cliques()

        edges = []
        for W in WW:
            X = [i for i in range(1,n+1) if sorted(W+[i]) in CC]			
            if len(X) >= 3:
                edges += [[sorted(W+[X[len(X)-1]]), sorted(W+[X[0]])]]
                edges += [[sorted(W+[X[j]]),sorted(W+[X[j+1]])] for j in range(len(X)-1)]
        for B in BB:
            Y = sorted([j for j in B if sorted(listminus(B,j)) in CC], reverse=True)
            if len(Y) >= 3:
                edges += [[sorted(listminus(B, Y[len(Y)-1])), sorted(listminus(B, Y[0]))]]
                edges += [ [sorted(listminus(B, Y[j])), sorted(listminus(B, Y[j+1]))] for j in range(len(Y)-1)] 
        edgesNew = []
        for e in edges:
            if e not in edgesNew:
                edgesNew.append(e)
        edges = edgesNew

        B = [[0 for i in range(NN)] for j in range(NN)]
        for e in edges:
            i,j = CCdict[tuple(e[0])], CCdict[tuple(e[1])]
            B[i][j] += 1
            B[j][i] += -1
        return B	
        
        


    def plabic_tiling(self, regions_color = 'gray', nodes_color = 'red'):
        r = 1
        k = self._k 
        NN = self._size
        n = self._n
        CC = self._collection
        CCdict = self._dictionary
        WW, BB = self.white_black_cliques()
        frozen_list = [sorted([x%n+1 for x in range(i,i+k)]) for i in range(n)]

        regions_plot = plot([], axes = False)
        nodes_plot = plot([], axes = False)
        vertex_list = [(r*cos(2*pi*i/n),r*sin(2*pi*i/n)) for i in range(n)]
        CC_xycoords = [(sum([vertex_list[i-1][0] for i in x]),sum([vertex_list[i-1][1] for i in x]))  for x in CC]
        CC_strings = ['$' + ''.join([str(y) for y in x])  + '$' for x in CC]

        for i in range(n):
            regions_plot += line([CC_xycoords[CCdict[tuple(frozen_list[i-1])]],CC_xycoords[CCdict[tuple(frozen_list[i])]]], color = regions_color)

        for B in BB:
            Y = sorted([j for j in B if sorted(listminus(B,j)) in CC], reverse=True)
            if len(Y) >= 3:
                regions_plot += polygon([CC_xycoords[CCdict[tuple(sorted(listminus(B, j)))]] for j in Y], color = regions_color, fill = True)			

        for i in range(NN):
            nodes_plot += point((CC_xycoords[i]), pointsize = 800, color = nodes_color, marker = CC_strings[i])
            nodes_plot[i].set_zorder(2)
		
        out_plot = regions_plot + nodes_plot
        return out_plot

    








